/*******************************************************************************
*
* McXtrace, xray-tracing package
*         Copyright, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Mirror_parabolic
*
* %I
* Written by: Erik Knudsen
* Date: Feb 11, 2010
* Version: $Revision$
* Origin: Risoe
*
* Idealized parabolic mirror
* 
* %D
* Takes a reflectivity (default=1) as input and reflects rays in a ideal geometry
* parabolic mirror. The mirror is positioned in the zx-plane curving towards positive y.
* I.e. the focal point is (0,0,f(a,b))
* Parabola is y = z^2 / a^2 + x^2 / b^2
* the focal length for the 'z' curve is f=a^2 / 4
*
* %P
* INPUT PARAMETERS
* R: [1] reflectivity of mirror.
* a: [sqrt(m)] (z) primary axis curvature scale
* b: [sqrt(m)] (x) curvature scale, if zero, flat in x.
* xmin: [m] lower bound of mirror in x (-width/2.0)
* xmax: [m] upper bound of mirror in x ( width/2.0)
* ymin: [m] lower bound of mirror in y (-height/2.0)
* ymax: [m] upper bound of mirror in y ( height/2.0)
* zmin: [m] lower bound of mirror in z (-depth/2.0)
* zmax: [m] upper bound of mirror in z ( depth/2.0)

* OUTPUT PARAMETERS
* xmax: [m] Mirrors' extent along x.
* zmax: [m] Mirrors' extent along z.
* %E
*******************************************************************************/


DEFINE COMPONENT Mirror_parabolic
DEFINITION PARAMETERS ()
  SETTING PARAMETERS (R=1, a=1, b=1, xwidth=0.1, zdepth=0.1, yheight=0)
OUTPUT PARAMETERS (a2inv,b2inv,xmax,zmax, focus)
/* X-ray parameters: (x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p) */ 

SHARE
%{


%}


DECLARE
%{
  double a2inv,b2inv, focus;
  double xmax,zmax;

%}

INITIALIZE
%{
  a2inv=1/(a*a);
  b2inv=(b!=0)?(1.0/(b*b)):0; /* if b==0, it is really infinity */
  focus=a*a/4.0;
%}

TRACE
%{
  int status;
  double l0,l1,sx,sz;
  double nx,ny,nz,zz;
  do {
    if (b==0 && kx==0 && ky==0){
      /*k || z and mirror invariant in z*/
      zz=x*x*a2inv;
      if(fabs(z-zz)<=yheight){
        ABSORB;
      }
    }
    if (a==0 && ky==0 && kz==0){
      /*k || x and mirror invariant in x*/
      zz=y*y*b2inv;
      if(fabs(z-zz)<=yheight){
        ABSORB;
      }
    }



    /*The intersect routine assumes a parabola opening towards positive z
     so swap y and z.*/
    status=paraboloid_intersect(&l0,&l1,x,z,y,kx,kz,ky, a,b,1);
    
    if (status){
      /*if l0==0, assume that we should pick l1 instead (if it is positive).*/
      if (l0>0){
        PROP_DL(l0);
      } else if (l1>0) {
        PROP_DL(l1);
      } else {
        /*both l0 and l1 <=0*/
        status=0;break;
      }
       /*need a check fro mirror limits here*/
      if(a!=0){
        sx= (a*a)/2.0 * ( x*a2inv * sqrt( (2*x*a2inv)*(2*x*a2inv) + 1) + asinh(2*x*a2inv)/2.0 );
      }else{
        sx=fabs(x);
      }
      if(b!=0){
        sz= (b*b)/2.0 * ( z*b2inv * sqrt( (2*z*b2inv)*(2*z*b2inv) + 1) + asinh(2*z*b2inv)/2.0 );
      }else{
        sz=fabs(z);
      }
      
      if( sx>xwidth/2.0 || sz>zdepth/2.0 ){
        /*Path length to either x or z coordinate bigger than mirror limits
         * => we have missed the mirror.*/
        RESTORE_XRAY(INDEX_CURRENT_COMP,x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p);
        status=0;
        break;
      }

      /*reflect in normal - again swap y and z.*/
      paraboloid_normal(&nx,&nz,&ny, x,z,y, a,b,1);

      printf("DEBUG: %g %g %g     %g %g %g",x,y,z,nx,ny,nz);

      double s=scalar_prod(kx,ky,kz,nx,ny,nz);
      if (s!=0){
        kx -= s*2*nx;
        ky -= s*2*ny;
        kz -= s*2*nz;
      }
      SCATTER;

      p*=R;
      /*update phase - as an approximation turn by 180 deg.*/
      phi+=M_PI;
    }
  }while(status);

  PROP_DL(0.1);
  printf("    DEBUG2: %g %g %g     %g %g %g\n",x,y,z,nx,ny,nz);

 
%}

MCDISPLAY
%{
%}

END
